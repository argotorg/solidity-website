---
title: 'SSA CFG'
date: '2025-12-23'
author: Solidity Team
category: Announcements
---

The Solidity `solc` compiler as of now has two major ways of transforming input Solidity and/or
[Yul code](https://docs.soliditylang.org/en/v0.8.33/yul.html) into EVM bytecode. You can find an overview
of these in the [A Closer Look at Via-IR](/blog/2024/07/12/a-closer-look-at-via-ir/) blogpost.

Conveniently, numerical IDs also improve the Yul IR pipeline in another pressing aspect: its compile-time performance.
Nevertheless, the underlying performance issues are of a more fundamental, algorithmic nature. In its current implementation, the code generation happens on a control flow graph (CFG) that is not in static single-assignment (SSA) form. Without the SSA property, data-flow-based optimizations - such as the commonly used common subexpression elimination - become computationally prohibitively expensive. Furthermore, there is no a priori liveness analysis but the liveness of variables is determined during bytecode generation implicitly by walking the CFG bottom-up from its exit nodes.

We aim to solve these performance issues by transforming the Yul IR into a CFG in SSA form. By doing that, we follow the footsteps of major compilers and employ algorithms that are proven to perform at a high level, albeit with different target platforms. Furthermore it allows us to perform classical liveness analysis upfront and based on that and the SSA-CFG, perform bytecode generation in a more constructive and maintainable top-down fashion.

To supplement this new and improved SSA pipeline, we collaborate with the [Costa group](https://costa.fdi.ucm.es/web/index.php) of the Complutense University of Madrid in Project GreY: a formerly Ethereum Foundation and currently Argot Collective funded project to develop novel greedy algorithms for translating Yul SSA-CFGs into EVM bytecode. As such, it can serve as methodical and theoretical underpinning of Solidity's future IR to EVM bytecode transformation.

While the previous paragraphs were all about compiler performance, one should also consider the performance of the generated bytecode: performance in terms of code size but also in terms of gas needed to interact with deployed contracts. Here, the SSA form can also help but it is undeniable that by transitioning from Solidity to Yul IR, some semantic information is lost or at least harder to recover. We are therefore exploring possibilities to make Yul itself more expressive, e.g., by extending Yul by type information, or by introducing more intermediate representations between classical/core Solidity and Yul that can not only capture type information but could contain, e.g., memory objects. These IRs could be defined using frameworks such as MLIR and open up more optimization opportunities, leading to more efficient bytecode.

## SSA CFG Backend

test $\sum_i$

test

$$
\sum_{i=1}^n \lim_{n\to\infty} \frac{1}{n^2}
$$

![SSA](/img/2025/ssa-post/shuf_compact.svg 'Figure 1: SSA caption test')
