---
title: 'SSA CFG'
date: '2025-12-23'
author: Solidity Team
category: Announcements
---

The Solidity `solc` compiler has two pathways ways of transforming input Solidity and/or
[Yul code](https://docs.soliditylang.org/en/v0.8.33/yul.html) into EVM bytecode. One, the so-called legacy pipeline,
transforms sourcecode directly into EVM bytecode. A more recent pipeline first goes to Yul, an intermediate 
representation (IR). [A Closer Look at Via-IR](/blog/2024/07/12/a-closer-look-at-via-ir/) provides and overview.

Here, we introduce a third pipeline that aims to solve long-standing performance issues in Via-IR as well as
improve "stack too deep" handling. Let's have a look at "stack too deep" first.

## What is stack too deep

The `solc` compiler targets the Ethereum Virtual Machine (EVM), which is a stack machine. Instructions' arguments
are the top-most values on the stack and upon execution replaced with return values. 

- add image here with stack example
- explain stack too deep

## Investigating the Via-IR performance

- 80% in the optimizer
- of which, a lot of time is spent in the DFA
- but also a lot of time in other components depending on the contract that is being compiled
- the dfa time is an algorithmic problem: the values of variables need to be tracked etc
- it would be easier if values never changed value, right?

## SSA-CFG form

- explainer

## Prototype
- always show how it differs from current codegen (topdown/bottom up, liveness, the shuffler approach)
- explainer with references:
  - ssa cfg builder
  - liveness with counts
  - codegen (how it works and why we need shuffling)
    - costa group work and references to the talks

We aim to solve these performance issues by transforming the Yul IR into a CFG in SSA form. By doing that, we follow the footsteps of major compilers and employ algorithms that are proven to perform at a high level, albeit with different target platforms. Furthermore it allows us to perform classical liveness analysis upfront and based on that and the SSA-CFG, perform bytecode generation in a more constructive and maintainable top-down fashion.

To supplement this new and improved SSA pipeline, we collaborate with the [Costa group](https://costa.fdi.ucm.es/web/index.php) of the Complutense University of Madrid in Project GreY: a formerly Ethereum Foundation and currently Argot Collective funded project to develop novel greedy algorithms for translating Yul SSA-CFGs into EVM bytecode. As such, it can serve as methodical and theoretical underpinning of Solidity's future IR to EVM bytecode transformation.

While the previous paragraphs were all about compiler performance, one should also consider the performance of the generated bytecode: performance in terms of code size but also in terms of gas needed to interact with deployed contracts. Here, the SSA form can also help but it is undeniable that by transitioning from Solidity to Yul IR, some semantic information is lost or at least harder to recover. We are therefore exploring possibilities to make Yul itself more expressive, e.g., by extending Yul by type information, or by introducing more intermediate representations between classical/core Solidity and Yul that can not only capture type information but could contain, e.g., memory objects. These IRs could be defined using frameworks such as MLIR and open up more optimization opportunities, leading to more efficient bytecode.

## SSA CFG Backend

test $\sum_i$

test

$$
\sum_{i=1}^n \lim_{n\to\infty} \frac{1}{n^2}
$$

![SSA](/img/2025/ssa-post/shuf_compact.svg 'Figure 1: SSA caption test')
